diff --git a/background.js b/background.js
index 4fdd7e8674dd68a1ee7a2ff9d4fe2c1f34fdcc95..2d6e4faeb40acc4fa0598d9c59326001dfeb5c7b 100644
--- a/background.js
+++ b/background.js
@@ -24,113 +24,127 @@ const tabState = {};
 let globalInstructions = "";
 
 // =================== Style profiles ===================
 const STYLE_PROFILES = {
   explicit: {
     label: "Explicit / Faithful",
     prompt: "Default adult manga translation. Faithful, natural, uncensored. Keep honorifics and tone.",
   },
   literal: {
     label: "Literal",
     prompt: "Word-for-word, preserve structure. Keep honorifics. Romanize SFX and add meaning in parentheses.",
   },
   localized: {
     label: "Localized / Smooth",
     prompt: "Rewrite for natural English. Adapt idioms. Honorifics may be dropped if it reads better.",
   },
   erotic: {
     label: "Erotic / Spicy",
     prompt: "Keep meaning but make the language more sensual, fluid, and arousing. Still uncensored.",
   },
   crude: {
     label: "Crude / Raw",
     prompt: "Preserve vulgarity and harshness. Avoid softening. Keep the raw tone.",
   },
 };
-const DEFAULT_STYLE = "explicit";
-
-function getStyleId(tid) {
-  return tabState[tid]?.styleId || DEFAULT_STYLE;
-}
-
-function getReadingOrder(tid) {
-  return tabState[tid]?.readingOrder || { auto: true, rtl: false, ttb: true };
-}
+const DEFAULT_STYLE = "explicit";
+
+function getStyleId(tid) {
+  return tabState[tid]?.styleId || DEFAULT_STYLE;
+}
+
+function getIgnoreSfx(tid) {
+  return tabState[tid]?.ignoreSfx ?? false;
+}
+
+function getReadingOrder(tid) {
+  return tabState[tid]?.readingOrder || { auto: true, rtl: false, ttb: true };
+}
 
 // =================== Page history for translation continuity ===================
 const pageHistory = {};
 const MAX_HISTORY  = 3;
 
 function getHist(tid)  { return pageHistory[tid] || []; }
 function pushHist(tid, text) {
   if (!pageHistory[tid]) pageHistory[tid] = [];
   pageHistory[tid].push(text);
   if (pageHistory[tid].length > MAX_HISTORY) pageHistory[tid].shift();
 }
 function replaceLastHist(tid, text) {
   if (pageHistory[tid]?.length) {
     pageHistory[tid][pageHistory[tid].length - 1] = text;
   } else {
     pushHist(tid, text);
   }
 }
 function clearHist(tid) { delete pageHistory[tid]; }
 
 function getAnalysisEnabled(tid) {
   return tabState[tid]?.analysisEnabled ?? true;
 }
 
 // =================== Filter translation output to only context-relevant content ===================
-function filterForContext(translationText, analysis) {
-  const lines = translationText.split("\n");
+function filterForContext(translationText, analysis) {
+  const lines = translationText.split("\n");
   let cat = null, trans = null;
   const kept = [];
 
   function flush() {
     if (trans !== null && (cat === "DIALOGUE" || cat === "NARRATION")) {
       kept.push("[" + cat + "] " + trans);
     }
     trans = null;
   }
 
   for (const raw of lines) {
     const line = raw.trim();
     const cm = line.match(/^\[(DIALOGUE|NARRATION|SFX|SIGN|TEXT)\]$/i);
     if (cm) { flush(); cat = cm[1].toUpperCase(); continue; }
     const tm = line.match(/^TRANSLATION:\s*(.*)$/i);
     if (tm) { trans = tm[1].trim(); continue; }
   }
   flush();
 
   let result = "";
   if (analysis) result += "Scene: " + analysis + "\n";
   if (kept.length) result += kept.join("\n");
-  return result.trim();
-}
-
-// =================== Story registry (compact running context per tab) ===================
-const storyRegistry = {};
+  return result.trim();
+}
+
+function filterSfxBlocks(text) {
+  const blocks = parseBlocksForQA(text);
+  if (!blocks.length) return text;
+  const kept = blocks.filter(block => block.cat !== "SFX");
+  if (!kept.length) return "No translatable text found.";
+  return kept.map(block =>
+    `[${block.cat}]\nORIGINAL: ${block.orig}\nTRANSLATION: ${block.trans}`
+  ).join("\n\n");
+}
+
+// =================== Story registry (compact running context per tab) ===================
+const storyRegistry = {};
 function getRegistry(tid)      { return storyRegistry[tid] || ""; }
 function setRegistry(tid, val) { storyRegistry[tid] = val; }
 
 async function updateStoryRegistry(tabId, analysis, filteredTranslation) {
   const current = getRegistry(tabId);
 
   const prompt = [
     "You maintain a compact story registry for a manga being translated page-by-page.",
     "Given the current registry and the latest page, output an UPDATED registry.",
     "",
     "RULES:",
     "- List each named CHARACTER with one short visual identifier and speech style",
     "- Note how characters ADDRESS each other (honorifics, nicknames)",
     "- Note key RELATIONSHIPS between characters",
     "- Summarize the CURRENT SITUATION in 1-2 sentences",
     "- Drop details that no longer matter for future translation",
     "- MAXIMUM 10 lines total. Be extremely concise.",
     "- If a character has not been named yet, use a placeholder like 'unnamed man'",
     "",
     "CURRENT REGISTRY:",
     current || "(empty â€“ first page)",
     "",
     "LATEST PAGE:",
     analysis ? "Scene: " + analysis : "",
     filteredTranslation,
@@ -299,154 +313,224 @@ If GLOBAL INSTRUCTIONS or a STYLE PROFILE are provided in the user message, foll
 Rules for NATURAL translation:
 â€¢ Rewrite the text so it sounds like a native ${TARGET_LANG} speaker wrote it. Prioritize flow and readability above all.
 â€¢ REMOVE or adapt honorifics to ${TARGET_LANG} equivalents where possible.
 â€¢ Convert Japanese idioms into equivalent ${TARGET_LANG} idioms or natural phrasing.
 â€¢ Convert onomatopoeia and SFX into vivid ${TARGET_LANG} action descriptions.
 â€¢ Adapt cultural references so a Western reader understands immediately without footnotes.
 â€¢ Dialogue must feel like real people talking â€” use contractions, casual phrasing, slang, and natural rhythm.
 â€¢ Sexual and explicit content must be translated faithfully with no censorship â€” make it sound natural and fluid.
 â€¢ Output ONLY the translated text. No commentary, no explanations.`;
 
 // =================== CONTEXT MENUS ===================
 browser.contextMenus.create({
   id: "vision-translate", title: "ðŸŒ Translate Image Text", contexts: ["image"],
 });
 browser.contextMenus.create({
   id: "vision-select-translate", title: "ðŸ” Select & Translate Region", contexts: ["image"],
 });
 
 browser.contextMenus.onClicked.addListener(async (info, tab) => {
   const imageUrl = info.srcUrl;
   const pageUrl  = info.pageUrl || "";
   const hCount   = getHist(tab.id).length;
   const analysisEnabled = getAnalysisEnabled(tab.id);
   const styleId = getStyleId(tab.id);
 
-  if (info.menuItemId === "vision-translate") {
-    try { await tell(tab.id, { action: "showOverlay", imageUrl, historyCount: hCount, analysisEnabled, styleId }); }
-    catch { await browser.tabs.executeScript(tab.id, { file: "content.js" }); await tell(tab.id, { action: "showOverlay", imageUrl, historyCount: hCount, analysisEnabled, styleId }); }
-    try {
-      const b64 = await imageToBase64Jpeg(imageUrl, pageUrl);
-      const prev = tabState[tab.id];
-      tabState[tab.id] = { b64, imageUrl, analysis: prev?.analysis || "", analysisEnabled, styleId, lastTranslation: prev?.lastTranslation || "" };
-      await streamTranslation(b64, tab.id, false);
-    } catch (err) { tell(tab.id, { action: "error", message: friendlyError(err) }); }
+  if (info.menuItemId === "vision-translate") {
+    const ignoreSfx = getIgnoreSfx(tab.id);
+    try {
+      await tell(tab.id, { action: "showOverlay", imageUrl, historyCount: hCount, analysisEnabled, styleId, ignoreSfx });
+    } catch {
+      await browser.tabs.executeScript(tab.id, { file: "content.js" });
+      await tell(tab.id, { action: "showOverlay", imageUrl, historyCount: hCount, analysisEnabled, styleId, ignoreSfx });
+    }
+    try {
+      const b64 = await imageToBase64Jpeg(imageUrl, pageUrl);
+      const prev = tabState[tab.id];
+      tabState[tab.id] = {
+        b64,
+        imageUrl,
+        analysis: prev?.analysis || "",
+        analysisEnabled,
+        styleId,
+        lastTranslation: prev?.lastTranslation || "",
+        ignoreSfx: prev?.ignoreSfx || false
+      };
+      await streamTranslation(b64, tab.id, false);
+    } catch (err) { tell(tab.id, { action: "error", message: friendlyError(err) }); }
 
   } else if (info.menuItemId === "vision-select-translate") {
     try { await tell(tab.id, { action: "showSelector", imageUrl, pageUrl }); }
     catch { await browser.tabs.executeScript(tab.id, { file: "content.js" }); await tell(tab.id, { action: "showSelector", imageUrl, pageUrl }); }
   }
 });
 
 // =================== MESSAGE HANDLING ===================
 browser.runtime.onMessage.addListener((msg, sender) => {
   const tabId = sender.tab?.id;
 
   if (msg.action === "retranslateEntry") {
     return handleRetranslate(msg.original, msg.style, tabId);
   }
 
   if (msg.action === "retranslateEntryWithNote") {
     return handleRetranslateWithNote(msg.original, msg.note, msg.currentTranslation, msg.styleId, tabId);
   }
 
   if (msg.action === "translateRegion") {
     (async () => {
       const hCount = getHist(tabId).length;
       const analysisEnabled = getAnalysisEnabled(tabId);
       const styleId = getStyleId(tabId);
       try {
-        await tell(tabId, { action: "showOverlay", imageUrl: msg.imageUrl, historyCount: hCount, analysisEnabled, styleId });
-      } catch {
-        await browser.tabs.executeScript(tabId, { file: "content.js" });
-        await tell(tabId, { action: "showOverlay", imageUrl: msg.imageUrl, historyCount: hCount, analysisEnabled, styleId });
-      }
-      try {
-        const b64 = await cropAndEncode(msg.imageUrl, msg.crop, msg.pageUrl);
-        const prev = tabState[tabId];
-        tabState[tabId] = { b64, imageUrl: msg.imageUrl, analysis: prev?.analysis || "", analysisEnabled, styleId, lastTranslation: prev?.lastTranslation || "" };
-        await streamTranslation(b64, tabId, false);
-      } catch (err) { tell(tabId, { action: "error", message: friendlyError(err) }); }
-    })();
+        const ignoreSfx = getIgnoreSfx(tabId);
+        await tell(tabId, { action: "showOverlay", imageUrl: msg.imageUrl, historyCount: hCount, analysisEnabled, styleId, ignoreSfx });
+      } catch {
+        await browser.tabs.executeScript(tabId, { file: "content.js" });
+        const ignoreSfx = getIgnoreSfx(tabId);
+        await tell(tabId, { action: "showOverlay", imageUrl: msg.imageUrl, historyCount: hCount, analysisEnabled, styleId, ignoreSfx });
+      }
+      try {
+        const b64 = await cropAndEncode(msg.imageUrl, msg.crop, msg.pageUrl);
+        const prev = tabState[tabId];
+        tabState[tabId] = {
+          b64,
+          imageUrl: msg.imageUrl,
+          analysis: prev?.analysis || "",
+          analysisEnabled,
+          styleId,
+          lastTranslation: prev?.lastTranslation || "",
+          ignoreSfx: prev?.ignoreSfx || false
+        };
+        await streamTranslation(b64, tabId, false);
+      } catch (err) { tell(tabId, { action: "error", message: friendlyError(err) }); }
+    })();
     return;
   }
 
   if (msg.action === "retry") {
     const state = tabState[tabId];
     if (!state) { tell(tabId, { action: "error", message: "No previous translation to retry." }); return; }
     (async () => {
       try { await streamTranslation(state.b64, tabId, true); }
       catch (err) { tell(tabId, { action: "error", message: friendlyError(err) }); }
     })();
     return;
   }
 
-  if (msg.action === "setAnalysisEnabled") {
-    const enabled = !!msg.enabled;
-    if (!tabState[tabId]) tabState[tabId] = { b64: null, imageUrl: null, analysis: "", analysisEnabled: enabled, styleId: DEFAULT_STYLE, lastTranslation: "" };
-    tabState[tabId].analysisEnabled = enabled;
-    if (!enabled) tabState[tabId].analysis = "";
-    return Promise.resolve({ analysisEnabled: enabled });
-  }
-
-  if (msg.action === "setStyle") {
-    const styleId = STYLE_PROFILES[msg.styleId] ? msg.styleId : DEFAULT_STYLE;
-    if (!tabState[tabId]) tabState[tabId] = { b64: null, imageUrl: null, analysis: "", analysisEnabled: true, styleId, lastTranslation: "" };
-    tabState[tabId].styleId = styleId;
-    return Promise.resolve({ styleId });
-  }
-
-  if (msg.action === "setGlobalInstructions") {
-    globalInstructions = (msg.text || "").trim();
-    return Promise.resolve({ ok: true });
-  }
-
-  if (msg.action === "setReadingOrder") {
-    const order = msg.readingOrder || {};
-    if (!tabState[tabId]) {
-      tabState[tabId] = { b64: null, imageUrl: null, analysis: "", analysisEnabled: true, styleId: DEFAULT_STYLE, lastTranslation: "" };
-    }
-    tabState[tabId].readingOrder = {
-      auto: order.auto !== false,
+  if (msg.action === "setAnalysisEnabled") {
+    const enabled = !!msg.enabled;
+    if (!tabState[tabId]) {
+      tabState[tabId] = {
+        b64: null,
+        imageUrl: null,
+        analysis: "",
+        analysisEnabled: enabled,
+        styleId: DEFAULT_STYLE,
+        lastTranslation: "",
+        ignoreSfx: false
+      };
+    }
+    tabState[tabId].analysisEnabled = enabled;
+    if (!enabled) tabState[tabId].analysis = "";
+    return Promise.resolve({ analysisEnabled: enabled });
+  }
+
+  if (msg.action === "setStyle") {
+    const styleId = STYLE_PROFILES[msg.styleId] ? msg.styleId : DEFAULT_STYLE;
+    if (!tabState[tabId]) {
+      tabState[tabId] = {
+        b64: null,
+        imageUrl: null,
+        analysis: "",
+        analysisEnabled: true,
+        styleId,
+        lastTranslation: "",
+        ignoreSfx: false
+      };
+    }
+    tabState[tabId].styleId = styleId;
+    return Promise.resolve({ styleId });
+  }
+
+  if (msg.action === "setIgnoreSfx") {
+    const ignoreSfx = !!msg.ignoreSfx;
+    if (!tabState[tabId]) {
+      tabState[tabId] = {
+        b64: null,
+        imageUrl: null,
+        analysis: "",
+        analysisEnabled: true,
+        styleId: DEFAULT_STYLE,
+        lastTranslation: "",
+        ignoreSfx
+      };
+    } else {
+      tabState[tabId].ignoreSfx = ignoreSfx;
+    }
+    return Promise.resolve({ ignoreSfx });
+  }
+
+  if (msg.action === "setGlobalInstructions") {
+    globalInstructions = (msg.text || "").trim();
+    return Promise.resolve({ ok: true });
+  }
+
+  if (msg.action === "setReadingOrder") {
+    const order = msg.readingOrder || {};
+    if (!tabState[tabId]) {
+      tabState[tabId] = {
+        b64: null,
+        imageUrl: null,
+        analysis: "",
+        analysisEnabled: true,
+        styleId: DEFAULT_STYLE,
+        lastTranslation: "",
+        ignoreSfx: false
+      };
+    }
+    tabState[tabId].readingOrder = {
+      auto: order.auto !== false,
       rtl: !!order.rtl,
       ttb: order.ttb !== false
     };
     return Promise.resolve({ readingOrder: tabState[tabId].readingOrder });
   }
 
   if (msg.action === "clearGlobalInstructions") {
     globalInstructions = "";
     return Promise.resolve({ ok: true });
   }
 
-  if (msg.action === "getGlobals") {
-    return Promise.resolve({
-      globalInstructions,
-      styleId: getStyleId(tabId),
-      readingOrder: getReadingOrder(tabId)
-    });
-  }
+  if (msg.action === "getGlobals") {
+    return Promise.resolve({
+      globalInstructions,
+      styleId: getStyleId(tabId),
+      readingOrder: getReadingOrder(tabId),
+      ignoreSfx: getIgnoreSfx(tabId)
+    });
+  }
 
   if (msg.action === "chat") {
     return handleChat(msg.text, tabId);
   }
 
   if (msg.action === "clearContext") {
     clearHist(tabId);
     delete storyRegistry[tabId];
     return Promise.resolve({ historyCount: 0 });
   }
 
   if (msg.action === "getHistoryCount") {
     return Promise.resolve({ historyCount: getHist(tabId).length });
   }
   if (msg.action === "getHistory") {
     return Promise.resolve({ history: getHist(tabId) });
   }
 });
 
 browser.tabs.onRemoved.addListener((tabId) => {
   delete tabState[tabId];
   delete pageHistory[tabId];
   delete storyRegistry[tabId];
 });
 
@@ -747,56 +831,59 @@ async function streamTranslation(base64Url, tabId, isRetry) {
   // â€”â€” Stage 2: Translation (streaming) â€”â€”
   const readingOrder = getReadingOrder(tabId);
   const autoOrder = readingOrder?.auto !== false;
   const detectedOrder = autoOrder ? detectReadingOrder(analysis) : null;
   let orderDirective = "";
   if (!autoOrder) {
     const dir = readingOrder?.rtl ? "RIGHT to LEFT" : "LEFT to RIGHT";
     const vertical = readingOrder?.ttb === false ? "bottom to top" : "top to bottom";
     orderDirective =
       "âš ï¸ READING ORDER: " + dir + ", " + vertical +
       ". You MUST translate text entries in this order across the page.";
     if (dir.includes("LEFT to RIGHT")) {
       orderDirective += " Do NOT use right-to-left manga order.\n\n";
     } else {
       orderDirective += " Do NOT use left-to-right manhwa order.\n\n";
     }
   } else if (detectedOrder) {
     orderDirective =
       "âš ï¸ READING ORDER: " + detectedOrder +
       ". You MUST translate text entries in this order across the page, top to bottom." +
       (detectedOrder.includes("LEFT to RIGHT")
         ? " Do NOT use right-to-left manga order.\n\n"
         : " Do NOT use left-to-right manhwa order.\n\n");
   }
 
-  const histPrefix = buildHistoryPrefix(tabId);
-  const parts = [];
-  if (globalInstructions) parts.push("GLOBAL INSTRUCTIONS:\n" + globalInstructions);
-  const styleBlock = buildStyleBlock(tabId);
-  if (styleBlock) parts.push(styleBlock);
-  if (histPrefix) parts.push(histPrefix);
+  const histPrefix = buildHistoryPrefix(tabId);
+  const parts = [];
+  if (globalInstructions) parts.push("GLOBAL INSTRUCTIONS:\n" + globalInstructions);
+  if (getIgnoreSfx(tabId)) {
+    parts.push("SFX FILTER:\nDo NOT output any entries in the [SFX] category. Skip sound effects entirely.");
+  }
+  const styleBlock = buildStyleBlock(tabId);
+  if (styleBlock) parts.push(styleBlock);
+  if (histPrefix) parts.push(histPrefix);
   if (analysis)   parts.push("Scene analysis for this page:\n" + analysis);
 
   const contextBlock = parts.length ? parts.join("\n\n") + "\n\n" : "";
   const userText = contextBlock + orderDirective + (isRetry ? USER_RETRY : USER_NORMAL);
 
   const payload = {
     messages: [
       { role: "system", content: isRetry ? SYS_RETRY : SYS_NORMAL },
       { role: "user", content: [
         { type: "image_url", image_url: { url: base64Url } },
         { type: "text", text: userText },
       ]},
     ],
     max_tokens: MAX_TOKENS, temperature: isRetry ? RETRY_TEMP : TEMPERATURE,
     stream: true,
     repeat_penalty: REPEAT_PENALTY, repeat_last_n: REPEAT_LAST_N,
     frequency_penalty: FREQUENCY_PENALTY, presence_penalty: PRESENCE_PENALTY,
     dry_multiplier: DRY_MULTIPLIER, dry_base: DRY_BASE,
     dry_allowed_length: DRY_ALLOWED_LENGTH, dry_penalty_last_n: DRY_PENALTY_LAST_N,
   };
 
   const res = await fetch(LLAMA_SERVER + "/v1/chat/completions", {
     method: "POST", headers: { "Content-Type": "application/json" },
     body: JSON.stringify(payload),
   });
@@ -811,53 +898,56 @@ async function streamTranslation(base64Url, tabId, isRetry) {
 
   while (true) {
     const { done, value } = await reader.read();
     if (done) break;
     buf += dec.decode(value, { stream: true });
     const lines = buf.split("\n"); buf = lines.pop();
     for (const line of lines) {
       const tr = line.trim();
       if (!tr.startsWith("data: ")) continue;
       const d = tr.slice(6);
       if (d === "[DONE]") break;
       try {
         const j = JSON.parse(d);
         const c = j.choices?.[0]?.delta?.content ?? "";
         if (c) {
           full += c;
           const clean = stripThink(full);
           if (clean && detectLoop(clean)) { aborted = true; reader.cancel(); break; }
           if (clean) tell(tabId, { action: "chunk", text: clean });
         }
       } catch {}
     }
     if (aborted) break;
   }
 
-  let final = stripThink(full);
-  final = final.replace(/\s*\/no_think\s*/gi, "");
-  final = dedupeOutput(final) || "No translatable text found.";
+  let final = stripThink(full);
+  final = final.replace(/\s*\/no_think\s*/gi, "");
+  final = dedupeOutput(final) || "No translatable text found.";
+  if (getIgnoreSfx(tabId)) {
+    final = filterSfxBlocks(final);
+  }
 
   // Save last translation for chat context
   if (tabState[tabId]) tabState[tabId].lastTranslation = final;
 
   // â€”â€” Save to page history (analysis + translation) â€”â€”
   const histEntry = filterForContext(final, analysis);
   if (isRetry) replaceLastHist(tabId, histEntry);
   else         pushHist(tabId, histEntry);
 
   // â€”â€” Update story registry in background â€”â€”
   updateStoryRegistry(tabId, analysis, histEntry);
 
   // â€”â€” Quality check (async) â€”â€”
   qualityCheck(final, tabId).catch(() => {});
 
   tell(tabId, { action: "done", text: final, historyCount: getHist(tabId).length });
 }
 
 // =================== QUALITY CHECK ===================
 function parseBlocksForQA(text) {
   const blocks = [];
   let cat = "TEXT", orig = null, trans = null;
   let inAnalysis = false;
 
   function flush() {
diff --git a/content.js b/content.js
index c7d869d8ad6d2365a5ebd5b538b28b67849151b7..f2ade372fa92b7ba314471b33c879f5f7029bbbc 100644
--- a/content.js
+++ b/content.js
@@ -388,136 +388,143 @@
       }
 
       const cm = line.match(/^\[(DIALOGUE|NARRATION|SFX|SIGN|TEXT)\]$/i);
       if (cm) {
         flush(); inAnalysis = false;
         cat = cm[1].toUpperCase(); continue;
       }
 
       if (inAnalysis) continue;
 
       const om = line.match(/^ORIGINAL:\s*(.*)$/i);
       if (om) { flush(); orig = om[1].trim(); continue; }
       const tm = line.match(/^TRANSLATION:\s*(.*)$/i);
       if (tm) { trans = tm[1].trim(); continue; }
     }
     flush();
     return blocks;
   }
 
   /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      Overlay / Panel
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
   let overlay = null, panelBody = null, ctxMenu = null, ctxBadge = null;
   let isStreaming = false, analysisOpen = false, currentImageUrl = null;
   let currentAnalysis = "", ctxModal = null;
-  let currentHistoryCount = 0;
-  let analysisEnabled = true;
-  let lastText = "";
-  let globalBox = null, globalStatus = null, globalTextarea = null;
-  let orderAuto = null, orderRtl = null, orderTtb = null;
-  let styleSelect = null;
-  let warnMap = {};
+  let currentHistoryCount = 0;
+  let analysisEnabled = true;
+  let ignoreSfx = false;
+  let lastText = "";
+  let globalBox = null, globalStatus = null, globalTextarea = null;
+  let orderAuto = null, orderRtl = null, orderTtb = null;
+  let ignoreSfxToggle = null;
+  let styleSelect = null;
+  let warnMap = {};
   const noteMap = new Map();
   const noteTimers = new Map();
   let docKeyHandler = null;
   let prevOverflow = "";
   let prevBodyOverflow = "";
 
   const STYLE_OPTIONS = [
     { id: "explicit", label: "Explicit / Faithful" },
     { id: "literal",  label: "Literal" },
     { id: "localized",label: "Localized / Smooth" },
     { id: "erotic",   label: "Erotic / Spicy" },
     { id: "crude",    label: "Crude / Raw" },
   ];
 
   function bindOverlayKeys() {
     if (docKeyHandler) return;
     docKeyHandler = (e) => {
       if (!overlay) return;
       if (overlay.contains(e.target)) {
         e.stopPropagation();
       }
     };
     document.addEventListener("keydown", docKeyHandler, true);
     document.addEventListener("keypress", docKeyHandler, true);
     document.addEventListener("keyup", docKeyHandler, true);
   }
 
   function unbindOverlayKeys() {
     if (!docKeyHandler) return;
     document.removeEventListener("keydown", docKeyHandler, true);
     document.removeEventListener("keypress", docKeyHandler, true);
     document.removeEventListener("keyup", docKeyHandler, true);
     docKeyHandler = null;
   }
 
   function updateBadge(count) {
     currentHistoryCount = count;
     if (!ctxBadge) return;
     if (count > 0) {
       ctxBadge.textContent = "ðŸ“– " + count + " page" + (count !== 1 ? "s" : "");
       ctxBadge.className = "vtl-badge-ctx vtl-has-ctx";
       ctxBadge.title = "Click to view stored context";
     } else {
       ctxBadge.textContent = "No context";
       ctxBadge.className = "vtl-badge-ctx";
       ctxBadge.title = "";
     }
   }
 
-  async function initGlobals() {
-    try {
-      const resp = await browser.runtime.sendMessage({ action: "getGlobals" });
-      if (resp?.globalInstructions != null && globalTextarea) {
-        globalTextarea.value = resp.globalInstructions;
-      }
-      if (resp?.styleId && styleSelect) {
-        styleSelect.value = resp.styleId;
-      }
-      if (resp?.readingOrder && orderAuto && orderRtl && orderTtb) {
-        const { auto, rtl, ttb } = resp.readingOrder;
-        orderAuto.checked = auto !== false;
-        orderRtl.checked = !!rtl;
-        orderTtb.checked = ttb !== false;
-      }
-    } catch {}
-  }
-
-  function showOverlay(imageUrl, historyCount, analysisFlag, styleId) {
-    closeOverlay();
-    injectCSS();
-    isStreaming = true;
-    analysisOpen = false;
-    currentAnalysis = "";
-    currentImageUrl = imageUrl;
-    lastText = "";
-    warnMap = {};
-    analysisEnabled = analysisFlag !== false;
-    prevOverflow = document.documentElement.style.overflow;
-    prevBodyOverflow = document.body.style.overflow;
+  async function initGlobals() {
+    try {
+      const resp = await browser.runtime.sendMessage({ action: "getGlobals" });
+      if (resp?.globalInstructions != null && globalTextarea) {
+        globalTextarea.value = resp.globalInstructions;
+      }
+      if (resp?.styleId && styleSelect) {
+        styleSelect.value = resp.styleId;
+      }
+      if (resp?.readingOrder && orderAuto && orderRtl && orderTtb) {
+        const { auto, rtl, ttb } = resp.readingOrder;
+        orderAuto.checked = auto !== false;
+        orderRtl.checked = !!rtl;
+        orderTtb.checked = ttb !== false;
+      }
+      if (resp?.ignoreSfx != null && ignoreSfxToggle) {
+        ignoreSfxToggle.checked = !!resp.ignoreSfx;
+        ignoreSfx = !!resp.ignoreSfx;
+      }
+    } catch {}
+  }
+
+  function showOverlay(imageUrl, historyCount, analysisFlag, styleId, ignoreSfxFlag) {
+    closeOverlay();
+    injectCSS();
+    isStreaming = true;
+    analysisOpen = false;
+    currentAnalysis = "";
+    currentImageUrl = imageUrl;
+    lastText = "";
+    warnMap = {};
+    analysisEnabled = analysisFlag !== false;
+    ignoreSfx = ignoreSfxFlag === true;
+    prevOverflow = document.documentElement.style.overflow;
+    prevBodyOverflow = document.body.style.overflow;
     document.documentElement.style.overflow = "hidden";
     document.body.style.overflow = "hidden";
 
     overlay = document.createElement("div");
     overlay.className = "vtl-overlay";
     overlay.addEventListener("click", e => { if (e.target === overlay) closeOverlay(); });
     bindOverlayKeys();
 
     const panel = document.createElement("div");
     panel.className = "vtl-panel";
 
     const accent = document.createElement("div");
     accent.className = "vtl-accent";
 
     const hdr = document.createElement("div");
     hdr.className = "vtl-header";
 
     const title = document.createElement("div");
     title.className = "vtl-title";
     title.innerHTML = '<span class="vtl-title-dot"></span> Translation';
 
     ctxBadge = document.createElement("span");
     updateBadge(historyCount || 0);
     ctxBadge.addEventListener("click", () => {
       if (currentHistoryCount > 0) openCtxViewer();
@@ -575,112 +582,122 @@
     hdr.append(title, styleSelect, clearBtn, analysisBtn, retryBtn, closeBtn);
 
     const content = document.createElement("div");
     content.className = "vtl-content";
 
     const left = document.createElement("div");
     left.className = "vtl-left";
 
     const info = document.createElement("div");
     info.className = "vtl-info";
     info.innerHTML =
       '<kbd>Retry</kbd> re-scans for missed text Â· <kbd>Right-click</kbd> a line to retranslate Â· Per-line notes auto-retranslate';
 
     panelBody = document.createElement("div");
     panelBody.className = "vtl-body";
     panelBody.innerHTML = '<div class="vtl-status vtl-pulse">Analysing scene</div>';
 
     // Global instructions box
     globalBox = document.createElement("div");
     globalBox.className = "vtl-global";
     const glabel = document.createElement("div");
     glabel.className = "vtl-global-label";
     glabel.textContent = "Global Instructions (all tabs, resets on restart)";
     globalTextarea = document.createElement("textarea");
     globalTextarea.placeholder = 'e.g. "Ignore SFX" or "Character A is male"';
-    const orderRow = document.createElement("div");
-    orderRow.className = "vtl-order";
-    const orderTitle = document.createElement("span");
-    orderTitle.textContent = "Reading order:";
+    const orderRow = document.createElement("div");
+    orderRow.className = "vtl-order";
+    const orderTitle = document.createElement("span");
+    orderTitle.textContent = "Reading order:";
     orderAuto = document.createElement("input");
     orderAuto.type = "checkbox";
     orderAuto.checked = true;
     const orderAutoLabel = document.createElement("label");
     orderAutoLabel.append(orderAuto, document.createTextNode("Auto"));
     orderRtl = document.createElement("input");
     orderRtl.type = "checkbox";
     const orderRtlLabel = document.createElement("label");
     orderRtlLabel.append(orderRtl, document.createTextNode("Right-to-left"));
     orderTtb = document.createElement("input");
     orderTtb.type = "checkbox";
     orderTtb.checked = true;
-    const orderTtbLabel = document.createElement("label");
-    orderTtbLabel.append(orderTtb, document.createTextNode("Top-to-bottom"));
-    orderRow.append(orderTitle, orderAutoLabel, orderRtlLabel, orderTtbLabel);
+    const orderTtbLabel = document.createElement("label");
+    orderTtbLabel.append(orderTtb, document.createTextNode("Top-to-bottom"));
+    const ignoreSfxLabel = document.createElement("label");
+    ignoreSfxToggle = document.createElement("input");
+    ignoreSfxToggle.type = "checkbox";
+    ignoreSfxToggle.checked = ignoreSfx;
+    ignoreSfxLabel.append(ignoreSfxToggle, document.createTextNode("Ignore SFX"));
+    orderRow.append(orderTitle, orderAutoLabel, orderRtlLabel, orderTtbLabel, ignoreSfxLabel);
     const gActions = document.createElement("div");
     gActions.className = "vtl-global-actions";
     const gApply = Object.assign(document.createElement("button"), { className: "vtl-btn", textContent: "Apply" });
     const gRetry = Object.assign(document.createElement("button"), { className: "vtl-btn", textContent: "Retranslate Page" });
     const gClear = Object.assign(document.createElement("button"), { className: "vtl-btn vtl-btn-clear", textContent: "Clear" });
     globalStatus = document.createElement("span");
     globalStatus.className = "vtl-global-status";
     globalStatus.textContent = "";
 
     gApply.onclick = async () => {
       try {
         await browser.runtime.sendMessage({ action: "setGlobalInstructions", text: globalTextarea.value });
         globalStatus.textContent = "Saved";
         setTimeout(() => { if (globalStatus) globalStatus.textContent = ""; }, 1200);
       } catch {}
     };
     function syncReadingOrder() {
       if (!orderAuto || !orderRtl || !orderTtb) return;
       const payload = {
         auto: orderAuto.checked,
         rtl: orderRtl.checked,
         ttb: orderTtb.checked
       };
       browser.runtime.sendMessage({ action: "setReadingOrder", readingOrder: payload });
     }
     orderAuto.addEventListener("change", () => {
       if (orderAuto.checked) {
         orderRtl.checked = false;
         orderTtb.checked = true;
       }
       syncReadingOrder();
     });
     orderRtl.addEventListener("change", () => {
       if (orderRtl.checked) orderAuto.checked = false;
       syncReadingOrder();
     });
-    orderTtb.addEventListener("change", () => {
-      if (!orderTtb.checked) orderAuto.checked = false;
-      syncReadingOrder();
-    });
-    gRetry.onclick = () => {
-      browser.runtime.sendMessage({ action: "retry" });
-    };
+    orderTtb.addEventListener("change", () => {
+      if (!orderTtb.checked) orderAuto.checked = false;
+      syncReadingOrder();
+    });
+    ignoreSfxToggle.addEventListener("change", () => {
+      ignoreSfx = ignoreSfxToggle.checked;
+      browser.runtime.sendMessage({ action: "setIgnoreSfx", ignoreSfx });
+      render(lastText, isStreaming);
+    });
+    gRetry.onclick = () => {
+      browser.runtime.sendMessage({ action: "retry" });
+    };
     gClear.onclick = async () => {
       try {
         await browser.runtime.sendMessage({ action: "clearGlobalInstructions" });
         globalTextarea.value = "";
         globalStatus.textContent = "Cleared";
         setTimeout(() => { if (globalStatus) globalStatus.textContent = ""; }, 1200);
       } catch {}
     };
 
     gActions.append(gApply, gRetry, gClear, globalStatus);
     globalBox.append(glabel, globalTextarea, orderRow, gActions);
 
     left.append(info, panelBody, globalBox);
 
     // Right panel: image + chat
     const right = document.createElement("div");
     right.className = "vtl-right";
 
     const imgWrap = document.createElement("div");
     imgWrap.className = "vtl-image-wrap";
     if (imageUrl) {
       const img = document.createElement("img");
       img.src = imageUrl;
       img.alt = "Source";
       img.draggable = false;
@@ -855,53 +872,53 @@
     if (!hdr) return;
     hdr.addEventListener("click", () => {
       analysisOpen = !analysisOpen;
       const body  = hdr.nextElementSibling;
       const arrow = hdr.querySelector(".vtl-analysis-arrow");
       body.style.display = analysisOpen ? "block" : "none";
       if (arrow) arrow.classList.toggle("open", analysisOpen);
     });
   }
 
   function buildAnalysisHTML() {
     if (!analysisEnabled || !currentAnalysis) return "";
     return '<div class="vtl-analysis">' +
       '<div class="vtl-analysis-hdr" data-vtl-toggle>' +
         '<span class="vtl-analysis-arrow' + (analysisOpen ? " open" : "") + '">â–¶</span>' +
         ' Scene Analysis' +
       '</div>' +
       '<div class="vtl-analysis-body" style="display:' + (analysisOpen ? "block" : "none") + '">' +
         esc(currentAnalysis) +
       '</div></div>';
   }
 
   /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      Render
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
-  function render(text, live) {
-    if (!panelBody) return;
-    const blocks = parseBlocks(text);
+  function render(text, live) {
+    if (!panelBody) return;
+    const blocks = parseBlocks(text).filter(block => !ignoreSfx || block.cat !== "SFX");
 
     let html = buildAnalysisHTML();
 
     if (!blocks.length) {
       if (text.trim()) {
         html += '<div class="vtl-raw">' + esc(text) + "</div>";
       }
       if (live) {
         html += '<div class="vtl-status vtl-pulse">Translating</div>';
       }
       panelBody.innerHTML = html;
       attachAnalysisToggle();
       return;
     }
 
     for (let i = 0; i < blocks.length; i++) {
       const b = blocks[i];
       const key = i + "|" + b.orig;
       const warn = warnMap[i];
       html += '<div class="vtl-block' + (warn ? " vtl-warn" : "") + '" data-i="' + i + '">' +
         (warn ? '<span class="vtl-warn-tag" title="' + escAttr(warn) + '">âš </span>' : "") +
         '<span class="vtl-badge vtl-badge-' + b.cat.toLowerCase() + '">' + b.cat + "</span>" +
         '<div class="vtl-orig">' + esc(b.orig) + "</div>" +
         '<div class="vtl-trans" data-orig="' + escAttr(b.orig) + '">' + esc(b.trans) + "</div>" +
         '<textarea class="vtl-note" rows="1" data-key="' + escAttr(key) + '" placeholder="Note for this line (auto-retranslate)â€¦"></textarea>' +
@@ -1122,55 +1139,55 @@
 
     const pointEl = document.elementFromPoint(sx, sy);
     const pointImg = pointEl?.closest && pointEl.closest("img");
     if (pointImg) return pointImg.getBoundingClientRect();
     const pointRect = elementRectForUrl(pointEl);
     if (pointRect) return pointRect;
 
     const centerEl = document.elementFromPoint(
       (sx + ex) / 2,
       (sy + ey) / 2
     );
     const centerImg = centerEl?.closest && centerEl.closest("img");
     if (centerImg) return centerImg.getBoundingClientRect();
     const centerRect = elementRectForUrl(centerEl);
     if (centerRect) return centerRect;
 
     const endEl = document.elementFromPoint(ex, ey);
     const endImg = endEl?.closest && endEl.closest("img");
     if (endImg) return endImg.getBoundingClientRect();
     return elementRectForUrl(endEl);
   }
 
   /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      Message listener
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
-  browser.runtime.onMessage.addListener(msg => {
-    switch (msg.action) {
-      case "showOverlay":
-        showOverlay(msg.imageUrl, msg.historyCount || 0, msg.analysisEnabled, msg.styleId);
-        break;
+  browser.runtime.onMessage.addListener(msg => {
+    switch (msg.action) {
+      case "showOverlay":
+        showOverlay(msg.imageUrl, msg.historyCount || 0, msg.analysisEnabled, msg.styleId, msg.ignoreSfx);
+        break;
       case "analysis":
         if (!analysisEnabled) break;
         currentAnalysis = msg.text || "";
         if (panelBody) render(lastText, true);
         break;
       case "chunk":
         lastText = msg.text || "";
         render(lastText, true);
         break;
       case "done":
         isStreaming = false;
         lastText = msg.text || "";
         render(lastText, false);
         if (msg.historyCount != null) updateBadge(msg.historyCount);
         break;
       case "quality":
         warnMap = {};
         (msg.items || []).forEach(it => { warnMap[it.index] = it.reason || "Low confidence"; });
         render(lastText, isStreaming);
         break;
       case "globalInstructionUpdate":
         if (globalTextarea) {
           globalTextarea.value = msg.text || "";
           toast("Global instruction added");
         }
